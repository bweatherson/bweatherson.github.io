<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.24">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Brian Weatherson">

<title>305 Lecture 11.7 - Frames and Philosophy</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dc55a5b9e770e841cd82e46aadbfb9b0.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-446815f2ff9f597c984ab84b572f1cc8.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent quarto-light">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">305 Lecture 11.7 - Frames and Philosophy</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Brian Weatherson </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="plan" class="level2">
<h2 class="anchored" data-anchor-id="plan">Plan</h2>
<ul>
<li>To go over why we should care about frames in philosophy classes, not just in logic classes.</li>
</ul>
</section>
<section id="associated-reading" class="level2">
<h2 class="anchored" data-anchor-id="associated-reading">Associated Reading</h2>
<ul>
<li>Boxes and Diamonds, section 4.3 to 4.5 (though a lot of what I say here isn’t in this book.)</li>
</ul>
</section>
<section id="thinking-about-possibility" class="level2">
<h2 class="anchored" data-anchor-id="thinking-about-possibility">Thinking about Possibility</h2>
<p>When we think about what these models might really mean, the <span class="math inline">\(R\)</span> relation is a kind of possibility.</p>
<ul>
<li><span class="math inline">\(wRx\)</span> means that if <span class="math inline">\(w\)</span> is how things actually are, then <span class="math inline">\(x\)</span> is a way things might be, in the sense of might that we care about. The point of the results in chapter 4 is that we now have two ways to think about these possibility claims.</li>
</ul>
<ol type="1">
<li>We can look at them directly, and this may tell us something about certain modal sentences.</li>
<li>Or we can look at the sentences, and that can tell us something about the possibility claims.</li>
</ol>
</section>
<section id="epistemic-modality" class="level2">
<h2 class="anchored" data-anchor-id="epistemic-modality">Epistemic Modality</h2>
<p>I want to walk through a bit how this plays out in contemporary debates in epistemology (the study of knowledge).</p>
<ul>
<li>We will treat <span class="math inline">\(\Box A\)</span> as meaning <em>Hero knows that A</em>.</li>
<li>So <span class="math inline">\(\Diamond A\)</span> means <em>For all hero knows, A</em>, or (roughly) <em>A might be true (from Hero’s perspective)</em>.</li>
<li>And <span class="math inline">\(wRx\)</span> means <em>If w is actual, then x is possible for Hero</em>. That is, if <span class="math inline">\(w\)</span> is actual, then for all Hero knows, they are actually in <span class="math inline">\(x\)</span>.</li>
</ul>
</section>
<section id="reflexivity" class="level2">
<h2 class="anchored" data-anchor-id="reflexivity">Reflexivity</h2>
<p>Remember there is a tight connection between these two claims.</p>
<ol type="1">
<li><span class="math inline">\(R\)</span> is reflexive, i.e., <span class="math inline">\(wRw\)</span> for all <span class="math inline">\(w\)</span>.</li>
<li>It is always true that <span class="math inline">\(\Box A \rightarrow A\)</span>.</li>
</ol>
</section>
<section id="reflexivity-and-epistemic-modals" class="level2">
<h2 class="anchored" data-anchor-id="reflexivity-and-epistemic-modals">Reflexivity and Epistemic Modals</h2>
<p>Both of these look like they should hold.</p>
<ol type="1">
<li>If Hero is in world <span class="math inline">\(w\)</span>, then for all she knows, she could be in world <span class="math inline">\(w \pause\)</span>.</li>
<li>If Hero knows that <span class="math inline">\(A\)</span>, then it is the case that <span class="math inline">\(A\)</span>.</li>
</ol>
</section>
<section id="symmetry" class="level2">
<h2 class="anchored" data-anchor-id="symmetry">Symmetry</h2>
<p>Remember there is a tight connection between these two claims.</p>
<ol type="1">
<li><span class="math inline">\(R\)</span> is symmetric, i.e., if <span class="math inline">\(wRx\)</span> then <span class="math inline">\(xRw\)</span>.</li>
<li>It is always true that <span class="math inline">\(A \rightarrow \Box \Diamond A \pause\)</span>.</li>
</ol>
<p>Question:</p>
<ul>
<li>Should this hold for the epistemic interpretation of <span class="math inline">\(\Box\)</span>?</li>
</ul>
</section>
<section id="symmetry-and-epistemic-modals" class="level2">
<h2 class="anchored" data-anchor-id="symmetry-and-epistemic-modals">Symmetry and Epistemic Modals</h2>
<p>This does not look particularly plausible. Let <span class="math inline">\(p\)</span> be something that’s actually true, but which Hero believes is false. (Hero could be anyone, so they could have false beliefs.) We’ll start thinking directly about the models.</p>
<ul>
<li>Let <span class="math inline">\(w_a\)</span> be the actual world, and <span class="math inline">\(w_b\)</span> the world in which everything is exactly as Hero thinks it is (in all respects).</li>
<li>Then <span class="math inline">\(w_aRw_b\)</span>, since <span class="math inline">\(w_b\)</span> is surely possible for Hero from the actual perspective.</li>
<li>But if she were in <span class="math inline">\(w_b\)</span>, then <span class="math inline">\(w_a\)</span> would not be possible, because she would know that <span class="math inline">\(p\)</span> is false, and in <span class="math inline">\(w_a\)</span> it is true.</li>
<li>So <span class="math inline">\(w_aRw_b\)</span> but not <span class="math inline">\(w_bRw_a\)</span>, showing symmetry fails.</li>
</ul>
</section>
<section id="symmetry-and-epistemic-modals-cont" class="level2">
<h2 class="anchored" data-anchor-id="symmetry-and-epistemic-modals-cont">Symmetry and Epistemic Modals (cont)</h2>
<p>Now think about the axiom</p>
<ul>
<li><span class="math inline">\(p \rightarrow \Box \Diamond p\)</span></li>
</ul>
<p>Remember Hero thinks <span class="math inline">\(p\)</span> is false, but it’s actually true. Is it the case that <span class="math inline">\(\Box \Diamond p \pause\)</span>. Presumably not. This means that Hero knows that <span class="math inline">\(p\)</span> might be true, but she thinks <span class="math inline">\(p\)</span> is false. So false beliefs are still a problem.</p>
</section>
<section id="transitivity" class="level2">
<h2 class="anchored" data-anchor-id="transitivity">Transitivity</h2>
<p>Remember there is a tight connection between these two claims.</p>
<ol type="1">
<li><span class="math inline">\(R\)</span> is transitive, i.e., if <span class="math inline">\(wRx\)</span> and <span class="math inline">\(xRy\)</span> then <span class="math inline">\(wRy\)</span>.</li>
<li>It is always true that <span class="math inline">\(\Box A \rightarrow \Box \Box A \pause\)</span>.</li>
</ol>
<p>Question:</p>
<ul>
<li>Should this hold for the epistemic interpretation of <span class="math inline">\(\Box\)</span>?</li>
</ul>
</section>
<section id="current-debate" class="level2">
<h2 class="anchored" data-anchor-id="current-debate">Current Debate</h2>
<ul>
<li>This is a much disputed question in the contemporary literature.</li>
<li>Here’s one way to think about it.</li>
<li>Is there some state of affairs that (a) Hero knows does not obtain, but (b) would be possible if the world was some other way, and (c) for all Hero knows the world is that way? </li>
<li>For a long time, philosophers (and computer scientists, economists etc) thought this was impossible, so they thought we should have <span class="math inline">\(\Box A \rightarrow \Box \Box A \pause\)</span>. But recently a number of philosophers have started thinking this isn’t true.</li>
</ul>
</section>
<section id="outside-philosophy" class="level2">
<h2 class="anchored" data-anchor-id="outside-philosophy">Outside Philosophy</h2>
<p>This is a philosophy course, so I’m going to focus on what happens in philosophy.</p>
<ul>
<li>But the issue has broader ramifications.</li>
<li>Lots of disciplines use models that include a representation of what various agents (living or artificial) know at different points.</li>
<li>And the standard way this is done doesn’t even allow for the representation of transitivity failures.</li>
<li>Indeed, it doesn’t even allow for symmetry failures, which is a bigger problem.</li>
<li>But the issue here is one that lots of theorists should worry about.</li>
</ul>
</section>
<section id="margins-of-error" class="level2">
<h2 class="anchored" data-anchor-id="margins-of-error">Margins of Error</h2>
<p>Think about the following situation.</p>
<ul>
<li>Hero is in a large lecture - maybe intro philosophy.</li>
<li>As often happens, they are a bit bored, and start estimating how many people are in the lecture theatre.</li>
<li>They are good at this kind of estimation, but not perfect.</li>
<li>But they are almost always within 10% of the correct count. That’s their <strong>margin of error</strong>.</li>
<li>Today they guess there are 200 students in the lecture, and (a little surprisingly) there are indeed exactly 200 students in the lecture.</li>
</ul>
</section>
<section id="margins-and-knowledge" class="level2">
<h2 class="anchored" data-anchor-id="margins-and-knowledge">Margins and Knowledge</h2>
<p>What does Hero know?</p>
<ul>
<li>Presumably they don’t know that there are precisely 200 students in the lecture.</li>
<li>After all, they aren’t usually this accurate.</li>
<li>But they do know that the number of students in somewhere between 180 and 220, since they are accurate to within 10%.</li>
</ul>
</section>
<section id="some-worlds" class="level2">
<h2 class="anchored" data-anchor-id="some-worlds">Some worlds</h2>
<p>Let <span class="math inline">\(w_n\)</span> be the world where there are precisely <span class="math inline">\(n\)</span> students in the lecture.</p>
<ul>
<li>So the actual world is <span class="math inline">\(w_{200}\)</span>.</li>
<li>And every world between <span class="math inline">\(w_{180}\)</span> and <span class="math inline">\(w_{220}\)</span> is possible. </li>
<li>But the worlds outside that range are not possible - Hero knows they do not obtain. Now think about which worlds are possible from <span class="math inline">\(w_{220}\)</span>. </li>
<li>In particular, should we think <span class="math inline">\(w_{220}Rw_{230}\)</span>?</li>
</ul>
</section>
<section id="whats-at-stake" class="level2">
<h2 class="anchored" data-anchor-id="whats-at-stake">What’s At Stake</h2>
<p>If <span class="math inline">\(w_{220}Rw_{230}\)</span> then transitivity fails.</p>
<ul>
<li>We have <span class="math inline">\(w_{200}Rw_{220}\)</span>.</li>
<li>And we have, by hypothesis, <span class="math inline">\(w_{220}Rw_{230}\)</span>.</li>
<li>But we don’t have <span class="math inline">\(w_{200}Rw_{230}\)</span>, since Hero actually knows that there are less than 230 students in the lecture. </li>
</ul>
<p>But if we don’t have <span class="math inline">\(w_{220}Rw_{230}\)</span>, then transitivity holds here. And this kind of case might be the best case for a transitivity failure.</p>
</section>
<section id="so-whats-right" class="level2">
<h2 class="anchored" data-anchor-id="so-whats-right">So What’s Right?</h2>
<p>Think about what Hero knows in the world where</p>
<ol type="1">
<li>There are actually 220 students in the lecture, and</li>
<li>She guesses there are 200 students. </li>
</ol>
<ul>
<li>On the one hand, her estimations are only accurate to within 10%, so it would be funny if she knew there were less than 230 students. That would mean she could rule out something that was within the margin of error of her estimation.</li>
</ul>
</section>
<section id="so-whats-right-1" class="level2">
<h2 class="anchored" data-anchor-id="so-whats-right-1">So What’s Right?</h2>
<p>Think about what Hero knows in the world where</p>
<ol type="1">
<li>There are actually 220 students in the lecture, and</li>
<li>She guesses there are 200 students. </li>
</ol>
<ul>
<li>On the other hand, she knows that she guessed 200. And she knows (we can assume) that she’s almost always within 10% of the truth. While she does not know this is one of the cases where she is this accurate, it actually is such a case. So maybe she can knowingly deduce (from her guess) that the crowd size is between 180 and 220.</li>
</ul>
</section>
<section id="a-verdict" class="level2">
<h2 class="anchored" data-anchor-id="a-verdict">A Verdict?</h2>
<p>I’m not going to adjudicate this here. Indeed it’s an open debate in the literature.</p>
<ul>
<li>What I do think is that thinking about these models, and in particular how they can be used to model noisy estimation of point values, is a helpful way to approach the problem.</li>
<li>It’s more helpful than thinking directly about whether someone could know something without knowing that they knew it.</li>
</ul>
</section>
<section id="for-next-time" class="level2">
<h2 class="anchored" data-anchor-id="for-next-time">For Next Time</h2>
<p>Next week, we’ll look at how we prove things in modal logic.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/bweatherson\.github\.io\/W26-Phil305-site");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>